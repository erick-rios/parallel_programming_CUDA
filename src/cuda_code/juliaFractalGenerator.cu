/**
 * @file juliaFractalGenerator.cu
 * @brief This file contains the implementation of a CUDA kernel that generates a Julia fractal image.
 * 
 * The kernel is executed to generate the Julia fractal image and the result is copied back to the host memory
 * to be displayed. The Julia fractal is generated by iterating the formula z = z^2 + c, where z is a complex
 * number and c is a constant. The color of each pixel is determined by the number of iterations required to
 * determine if the pixel is inside the Julia set.
 * 
 * @author Erick Jesús Ríos González
 * @date 17/09/2024
 */

#include <iostream>
#include <opencv2/opencv.hpp>
#include <cuda_runtime.h>

using namespace std;
using namespace cv;

#define WIDTH 800  // Ancho de la imagen
#define HEIGHT 800 // Altura de la imagen

// Julia's constant formula parameters
const float C_RE = -0.7f;  // Real part of the constant c
const float C_IM = 0.27015f;  // Imaginary part of the constant c
const int MAX_ITER = 1000;  // Maximum number of iterations

/**
 * @brief Structure that represents a 3-channel color pixel.
 * 
 * The structure contains the red, green, and blue components of a color pixel.
 * 
 * @param int iter Number of iterations required to determine if the pixel is inside the Julia set.
 * 
 * @return uchar3 Color pixel.
 */
__device__ uchar3 colorPixel(int iter) {
    uchar3 color;
    if (iter == MAX_ITER) {
        color.x = color.y = color.z = 0;  // Black if the pixel is inside the Julia set
    } else {
        float t = (float)iter / MAX_ITER;
        color.x = (unsigned char)(9 * (1 - t) * t * t * t * 255); // R
        color.y = (unsigned char)(15 * (1 - t) * (1 - t) * t * t * 255); // G
        color.z = (unsigned char)(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255); // B
    }
    return color;
}

/**
 * @brief CUDA kernel that generates a Julia fractal image.
 * 
 * The kernel generates the Julia fractal image by iterating the formula z = z^2 + c, where z is a complex number
 * 
 * @param image Image data.
 * @param scaleX Scale factor for the x-axis.
 * @param scaleY Scale factor for the y-axis.
 */
__global__ void juliaKernel(uchar3* image, float scaleX, float scaleY) {
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    int row = blockIdx.y * blockDim.y + threadIdx.y;

    if (col < WIDTH && row < HEIGHT) {
        float x = scaleX * (col - WIDTH / 2.0f);
        float y = scaleY * (row - HEIGHT / 2.0f);
        int iter = 0;

        // Iteración de la fórmula de Julia
        while (x*x + y*y < 4.0f && iter < MAX_ITER) {
            float x_new = x*x - y*y + C_RE;
            y = 2*x*y + C_IM;
            x = x_new;
            iter++;
        }

        // Almacenar el color calculado
        image[row * WIDTH + col] = colorPixel(iter);
    }
}

/**
 * @brief Main function.
 * 
 * The main function initializes the data, allocates memory on the host and device, executes the kernel on the GPU,
 * 
 * @return 0 if the execution was successful.
 */
int main() {
    // 1. Inicialización de datos
    float scaleX = 3.0f / WIDTH;
    float scaleY = 3.0f / HEIGHT;

    // 2. Asignación de memoria en el Host
    uchar3* hostImage = (uchar3*)malloc(WIDTH * HEIGHT * sizeof(uchar3));

    // 3. Asignación de memoria en el Device (GPU)
    uchar3* deviceImage;
    cudaMalloc((void**)&deviceImage, WIDTH * HEIGHT * sizeof(uchar3));

    // 4. Configuración de la ejecución en la GPU
    dim3 blockSize(16, 16);
    dim3 gridSize((WIDTH + blockSize.x - 1) / blockSize.x, (HEIGHT + blockSize.y - 1) / blockSize.y);

    // 5. Ejecutar el kernel en la GPU
    juliaKernel<<<gridSize, blockSize>>>(deviceImage, scaleX, scaleY);
    cudaDeviceSynchronize();

    // 6. Transferencia de datos del Device al Host
    cudaMemcpy(hostImage, deviceImage, WIDTH * HEIGHT * sizeof(uchar3), cudaMemcpyDeviceToHost);

    // 7. Validación de resultados: Crear y mostrar la imagen del fractal
    Mat outputImage(HEIGHT, WIDTH, CV_8UC3, hostImage);
    imwrite("../../images/julia_fractal.png", outputImage);
    imshow("Julia Fractal", outputImage);
    waitKey(0);

    // 8. Liberación de Memoria
    free(hostImage);
    cudaFree(deviceImage);

    return 0;
}
